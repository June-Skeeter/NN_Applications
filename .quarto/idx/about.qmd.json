{"title":"A Framework for Applying Neural Networks to Eddy Covariance Data","markdown":{"yaml":{"title":"A Framework for Applying Neural Networks to Eddy Covariance Data","jupyter":"python3","echo":false,"fig-dpi":300,"format":{"revealjs":{"code-fold":true,"controls":true,"navigation-mode":"linear","controls-layout":"bottom-right","controls-tutorial":true,"slide-number":true,"show-slide-number":"all","pdfMaxPagesPerSlide":1}},"author":[{"name":"Dr. June Skeeter","email":"june.skeeter@ubc.ca","url":"https://github.com/June-Skeeter","affiliations":[{"ref":"UBC"}]}],"affiliations":[{"id":"UBC","name":"University British Columbia","department":"Department Geography","address":"1984 West Mall","city":"Vancouver, BC, Canada","postal-code":"V6T 1Z2"}],"keywords":["Eddy Covariance","Micrometeorology","Neural Networks","Modelling"]},"headingText":"Eddy Covariance","containsRefs":false,"markdown":"\n\n\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\nSemi-continuous, ecosystem-scale measurements of energy, water, and trace gas fluxes.\n\n* Noisy, voluminous data sets\n  * Frequent gaps\n  * Observational bias\n* Well suited for machine learning!\n\n:::\n\n::: {.column width=\"50%\"}\n\n<img src=\"images/BB1_System.jpg\" alt=\"your-image-description\" style=\"border: 2px solid  black;\">\n\n<h3>Burns Bog EC Station<br>Delta, BC</h3>\n\n:::\n\n::::\n\n\n## Neural Networks\n\n**Universal approximators**: can map any continuous function to an arbitrary degree accuracy.\n\n* With enough hidden nodes, will fit **any** pattern in a dataset\n  * Care must be taken to ensure the patterns are real\n  * Early stopping allows \n\n* Well suited for non-linear, multi-variate response functions\n  * Capable **interpolation** and *extrapolation*\n\n\n## Commonly Cited Limitations\n\n```{python}\n#| tbl-colwidths: [40,60]\n\nimport numpy as np\nimport pandas as pd\nfrom sklearn import metrics\nfrom tabulate import tabulate\nfrom IPython.display import Markdown\n\ndf = pd.read_csv('About.csv',sep='|',index_col='Drawback')\nMarkdown(tabulate(\n  df, \n  headers=[\"Issue\", \"Solutions\"]\n))\n\n```\n\n# Objective\n\nProvide a framework for applying NN models to EC data for descriptive analysis and inferential modelling. \n \n* The [github repository](https://github.com/June-Skeeter/NN_Applications) linked to this presentation has functional examples that can be used to apply NN models.\n  * Runs in Python and Tensorflow\n    * *GPU support not required*\n\n## Example Data\n\n:::: {.columns}\n\n::: {.column width=\"45%\"}\n\nBurns Bog EC station\n\n* Harvested peatland undergoing active restoration\n* 8+ years of meteorological & flux (CO<sub>2</sub> and CH<sub>4</sub>) data\n\n:::\n\n::: {.column width=\"55%\"}\n\n\n<img src=\"images/BB1.jpg\" alt=\"your-image-description\" style=\"border: 2px solid  black; width: 100%\">\n\n:::\n::::\n\n\n## Training Procedures\n\n\n:::: {.columns}\n\n::: {.column width=\"70%\"}\n\n* Larger ensemble = more robust model\n  * N <= 10 for data exploration/pruning\n* Three way cross-validation\n  * Train/validate/test\n* Early Stopping: after **e** epochs\n  * e = 2 for pruning stage\n\n:::\n\n::: {.column width=\"30%\"}\n\n<img src=\"images/NN_Workflows.png\" alt=\"your-image-description\">\n\n\n:::\n\n::::\n\n## Pruning Inputs\n\nCalculate partial first derivative of the output with respect to each input over test data domain.\n\n* **Relative Influence (RI)** of inputs\n  * Normalized sum of squared derivatives (SSD)\n\n* Iteratively remove inputs with RI below a threshold\n  * Use set of random scalars inputs to determine threshold\n    * e.g., a float [0-1], a skewed float [0-1]<sup>.25</sup>, and a binary integer (0/1)\n\n## Before and After Pruning FCO<sub>2</sub>\n\n```{python}\n#| label: RI of FCO2 models\n#| layout-ncol: 1\n#| warning: False\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom Scripts import MiscFuncs,PlotHelpers\n\nfig,ax=plt.subplots(1,2,sharey=True,sharex=True)\n\nBase = 'FCO2'\nFull = 'Full'\nName = f'{Full}_Model_{Base}'\nRI = pd.read_csv(f'Models/{Base}/{Name}/model_RI.csv',index_col=[0])\nRI = RI.sort_values(by=f'RI_bar',ascending=True)\nPlotHelpers.makeRI_plot(ax[0],RI,Title='Over-Parametrized Model for FCO$_2$')\n\nFinal='Final'\nName = f'{Final}_Model_{Base}'\nRI = pd.read_csv(f'Models/{Base}/{Name}/model_RI.csv',index_col=[0])\nRI = RI.sort_values(by=f'RI_bar',ascending=True)\nPlotHelpers.makeRI_plot(ax[1],RI,Title='Pruned Model for FCO$_2$')\nax[1].set_ylabel('')\nplt.tight_layout()\n\n```\n\n## The Final Model\n\nOnce pruning is complete, re-train the final production level model, excluding the random scalars\n\n* Increase the ensemble size (e.g., N =30)\n  * Could increase early stopping criteria (e.g., e = 10)\n  * Larger e drastically increases training\n* Plot the model derivatives as a final check\n  * If derivatives look implausible \n    * Adjust inputs/parameters and try again\n\n\n## Plotting Derivatives\n    \nHelps ensure model responses are physically plausible\n\n* An **essential step** and **key advantage** of NN models\n* Raw derivatives show true feature responses\n* Normalized derivatives scaled by input variance\n  * Relative input effects on common scale\n  * What the model \"sees\"\n* 95% confidence intervals around derivatives indicate modeled confidence in relationships\n\n\n## Partial Derivatives of FCO<sub>2</sub>\n \n \n```{python}\n#| label: Derivatives of final FCO2 model\n#| layout-ncol: 1\n#| warning: False\n\nBase = 'FCO2'\n\nName = f'{Final}_Model_{Base}'\n\nRI = pd.read_csv(f'Models/{Base}/{Name}/model_RI.csv',index_col=[0])\nRI = RI.sort_values(by=f'RI_bar',ascending=True)\ndf = pd.read_csv(f'Models/{Base}/{Name}/model_output.csv',index_col=[0])\n\n# Max=4\n#RI.sort_values(by=f'RI_bar',ascending=False).index[:Max]\n\nShow = ['PPFD','T air']\n\ncols = 2\nnpi=len(RI.index)\nrows = int(np.ceil(len(Show)/cols))\n\nfig,axes=plt.subplots(rows,cols)\n\naxes = axes.flatten()\n\nmod = ''\n\nfor i,xi in enumerate(Show):\n    df_int = MiscFuncs.byInterval(df,f'{xi}',[f'dy_d{xi}{mod}'],bins=50)\n    PlotHelpers.CI_Plot(axes[i],df_int,f'dy_d{xi}{mod}')\n    axes[i].set_title(xi)\n\nplt.tight_layout()\n\naxes[i].get_ylabel()\n\nfor ax in axes:\n    l = ax.get_ylabel()\n    ax.set_ylabel(l.split('_norm')[0].replace('_',' / ').replace('y','FCO2'))\n\n\nradom_code_to_mask_text=0\n\n```\n\n## Normalized Derivatives of FCO<sub>2</sub>\n \n```{python}\n#| label: Normalized Derivatives of final model\n#| layout-ncol: 1\n#| warning: False\n\nimport numpy as np\n\n# Max=4\n# Top = RI.sort_values(by=f'RI_bar',ascending=False).index[:Max]\n\ncols = 2\n# npi=len(RI.index)\nrows = int(np.ceil(len(Show)/cols))\n\nfig,axes=plt.subplots(rows,cols,sharey=True,sharex=True)\n\naxes = axes.flatten()\n\nmod = '_norm'\n\nfor i,xi in enumerate(Show):\n    axes[i].axvspan(0,0,edgecolor='k',linewidth=1.5)\n    df_int = MiscFuncs.byInterval(df,f'{xi}{mod}',[f'dy_d{xi}{mod}'],bins=50)\n    PlotHelpers.CI_Plot(axes[i],df_int,f'dy_d{xi}{mod}')\n    axes[i].set_title(xi)\nplt.tight_layout()\naxes[i].get_ylabel()\nfor ax in axes:\n    l = ax.get_ylabel()\n    ax.set_ylabel(l.split('_')[0]+'/dx')\n\n```\n\n\n## Model Performance FCO<sub>2</sub>\n\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\nPlot the model outputs and validation metrics calculated with the test data.\n\n::: {style=\"font-size: 80%;\"}\n\n```{python}\n#| label: Validation FCO2\n#| layout-ncol: 1\n#| warning: False\n#| tbl-colwidths: [25,75]\n\n\nunit = '$\\mu mol$ $m^{-2}s^{-1}$'\n\nx,y='target','y_bar'\nr2 = str(np.round(metrics.r2_score(df[x],df[y]),2))\nRMSE = str(np.round(metrics.mean_squared_error(df[x],df[y])**.5,2))+f' {unit}'\n\nm = pd.DataFrame(index=['RMSE','r<sup>2</sup>'],data={'Metrics':[RMSE,r2]})\nMarkdown(tabulate(\n  m, \n  headers=[\"Metric\", \"Score\"]\n))\n\n\n```\n\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n```{python}\n#| label: Performance of final FCH4 model\n#| layout-ncol: 1\n#| warning: False\n\ndf = pd.read_csv(f'Models/{Base}/{Name}/model_output.csv',index_col=[0])\n\nunit = '$\\mu mol m^{-2} s^{-1}$'\n\nfig,ax=plt.subplots(figsize=(5,5))\nax = PlotHelpers.make1_1_Plot(ax,df,'target','y_bar',unit=unit)\nax.set_ylabel('NN Estimate')\nax.set_xlabel('EC Observation')\nax.set_title('')\nradom_code_to_mask_text=0\n\n```\n\n\n:::\n\n::::\n\n\n## Before and After Pruning FCH<sub>4</sub>\n\n```{python}\n#| label: RI of FCH4 models\n#| layout-ncol: 1\n#| warning: False\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom Scripts import MiscFuncs,PlotHelpers\n\nfig,ax=plt.subplots(1,2,sharey=True,sharex=True)\n\nBase = 'FCH4'\nName = f'{Full}_Model_{Base}'\nRI = pd.read_csv(f'Models/{Base}/{Name}/model_RI.csv',index_col=[0])\nRI = RI.sort_values(by=f'RI_bar',ascending=True)\nPlotHelpers.makeRI_plot(ax[0],RI,Title='Over-Parametrized Model for FCH$_4$')\n\nName = f'{Final}_Model_{Base}'\nRI = pd.read_csv(f'Models/{Base}/{Name}/model_RI.csv',index_col=[0])\nRI = RI.sort_values(by=f'RI_bar',ascending=True)\nPlotHelpers.makeRI_plot(ax[1],RI,Title='Pruned Model for FCH$_4$')\nax[1].set_ylabel('')\nplt.tight_layout()\n\n```\n\n\n\n## Normalized Derivatives of FCH<sub>4</sub>\n \n \n```{python}\n#| label: Derivatives of final FCH4 model\n#| layout-ncol: 1\n#| warning: False\n\nBase = 'FCH4'\n\nName = f'{Final}_Model_{Base}'\n\nRI = pd.read_csv(f'Models/{Base}/{Name}/model_RI.csv',index_col=[0])\nRI = RI.sort_values(by=f'RI_bar',ascending=True)\ndf = pd.read_csv(f'Models/{Base}/{Name}/model_output.csv',index_col=[0])\n\n# Max=4\n#RI.sort_values(by=f'RI_bar',ascending=False).index[:Max]\n\nShow = ['T soil 50cm','Water table']\n\ncols = 2\nnpi=len(RI.index)\nrows = int(np.ceil(len(Show)/cols))\n\nfig,axes=plt.subplots(rows,cols)\n\naxes = axes.flatten()\n\nmod = '_norm'\n\nfor i,xi in enumerate(Show):\n    df_int = MiscFuncs.byInterval(df,f'{xi}{mod}',[f'dy_d{xi}{mod}'],bins=50)\n    PlotHelpers.CI_Plot(axes[i],df_int,f'dy_d{xi}{mod}')\n    axes[i].set_title(xi)\n\nplt.tight_layout()\n\naxes[i].get_ylabel()\n\nfor ax in axes:\n    l = ax.get_ylabel()\n    ax.set_ylabel(l.split('_norm')[0].replace('_',' / ').replace('y','FCO2'))\n\n\nradom_code_to_mask_text=0\n\n```\n\n## Model Performance FCH<sub>4</sub>\n\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\nPlot the model outputs and validation metrics calculated with the test data.\n\n::: {style=\"font-size: 80%;\"}\n\n```{python}\n#| label: Validation FCH4\n#| layout-ncol: 1\n#| warning: False\n#| tbl-colwidths: [25,75]\n\n\nunit = '$\\mu mol$ $m^{-2}s^{-1}$'\n\nx,y='target','y_bar'\nr2 = str(np.round(metrics.r2_score(df[x],df[y]),2))\nRMSE = str(np.round(metrics.mean_squared_error(df[x],df[y])**.5,2))+f' {unit}'\n\nm = pd.DataFrame(index=['RMSE','r<sup>2</sup>'],data={'Metrics':[RMSE,r2]})\nMarkdown(tabulate(\n  m, \n  headers=[\"Metric\", \"Score\"]\n))\n\n\n```\n\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n```{python}\n#| label: Performance of final FCO2 model\n#| layout-ncol: 1\n#| warning: False\n\ndf = pd.read_csv(f'Models/{Base}/{Name}/model_output.csv',index_col=[0])\n\nunit = '$\\mu mol m^{-2} s^{-1}$'\n\nfig,ax=plt.subplots(figsize=(5,5))\nax = PlotHelpers.make1_1_Plot(ax,df,'target','y_bar',unit=unit)\nax.set_ylabel('NN Estimate')\nax.set_xlabel('EC Observation')\nax.set_title('')\nradom_code_to_mask_text=0\n\n```\n\n\n:::\n\n::::\n\n\n## Next Steps\n\n* Custom NN architecture: Separating input layers may allow us partition fluxes.\n  * e.g., FCO<sub>2</sub> into GPP and ER\n* Flux footprints: map response to spatial heterogenity\n* Upscaling: in space and time\n* u* filtering: partial derivatives could identify u* thresholds\n* Compare to process based models (e.g., CLASSIC)\n\n# Thank You\n\nQuestions?\n"},"formats":{"revealjs":{"execute":{"fig-width":10,"fig-height":5,"fig-format":"retina","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":false,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","html-math-method":{"method":"mathjax","url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML-full"},"slide-level":2,"to":"revealjs","output-file":"about.html"},"language":{},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.2.335","auto-stretch":true,"title":"A Framework for Applying Neural Networks to Eddy Covariance Data","jupyter":"python3","author":[{"name":"Dr. June Skeeter","email":"june.skeeter@ubc.ca","url":"https://github.com/June-Skeeter","affiliations":[{"ref":"UBC"}]}],"affiliations":[{"id":"UBC","name":"University British Columbia","department":"Department Geography","address":"1984 West Mall","city":"Vancouver, BC, Canada","postal-code":"V6T 1Z2"}],"keywords":["Eddy Covariance","Micrometeorology","Neural Networks","Modelling"],"controls":true,"navigationMode":"linear","controlsLayout":"bottom-right","controlsTutorial":true,"slideNumber":true,"showSlideNumber":"all","pdfMaxPagesPerSlide":1}}}}