{"title":"A Framework for Applying Neural Networks to Eddy Covariance Data","markdown":{"yaml":{"title":"A Framework for Applying Neural Networks to Eddy Covariance Data","jupyter":"python3","format":{"revealjs":{"code-fold":true,"controls":true,"navigation-mode":"linear","controls-layout":"bottom-right","controls-tutorial":true,"slide-number":true,"show-slide-number":"all","pdfMaxPagesPerSlide":1}},"author":[{"name":"Dr. June Skeeter","email":"june.skeeter@ubc.ca","url":"https://github.com/June-Skeeter","affiliations":[{"ref":"UBC"}]}],"affiliations":[{"id":"UBC","name":"University of British Columbia","department":"Department of Geography","address":"1984 West Mall","city":"Vancouver, BC, Canada","postal-code":"V6T 1Z2"}],"keywords":["Eddy Covariance","Micrometeorology","Neural Networks","Modelling"],"citeproc":true,"bibliography":"ML_EC.bib"},"headingText":"Introduction","containsRefs":false,"markdown":"\n\n\nNeural networks (NN) are flexible, powerful machine learing algorithms.\n\n* **Universal approximators**: can map any continuous function to an arbitrary degree fo accuracy.\n    * Given sufficient \"hidden nodes\", will fit **any** pattern in a dataset\n        * Care must be taken to ensure the paterns are real\n\n## Introduction\n\n:::: {.columns}\n\n::: {.column width=\"40%\"}\n\n### Pros\n\n* Well suited for non-linear, multi-variate response functions\n* Robust to over-fitting\n\n:::\n\n::: {.column width=\"60%\"}\n\n### Cons\n\n* Computationally expensive\n* Complex and difficult to implement\n* \"Black Boxes\"\n\n:::\n\n::::\n\n## Introduction\n\nEddy Covariance (EC) measures spatially integrated, semi-continouous, ecosystem-scale fluxes of energy, water, and trace gas.\n\n* Noisy, voluminous EC data sets are poorly suited for traditional statistical methods @wegman_computational_1988\n    * Site to site varriability makes standard ana approaches are often needed\n\n* We need to ensure our results are reasonable given our understanding of the system.\n    * And if they don't, we need to be able to investigate **why**\n  \n* As the period of record at flux sites extend (e.g, decades) the task only becomes more complex\n    * A sliver lining: voluminous data sets are ideally suited for computational statistics!\n\n# Objectives\n\nProvide a tool set with functional examples demonstrating how NN models can be applied to EC data for both descriptive analysis and inferential modelling.\n \n* The [github repository](https://github.com/June-Skeeter/NN_Applications) linked to this presentation has Python code that can be used to apply NN models.\n\n\n## A Simple 2D Example Calculating and Visualizing VPD\n\nThe Vapor Pressure Deficit (VPD) decreases exponentially as a function of air temperature (Ta) and linearly as a function of relative humidity (RH).  We can calculate VPD (kPa) from Ta in ($\\circ$ C) and RH (%) as follows:\n\n$$ ea_H = 0.61365*np.exp((17.502*Ta)/(240.97+Ta))$$\n$$e_H = RH*ea_H/100$$\n$$VPD = (ea_H - e_H)*10$$\n\n```{python}\n#| label: Estimating VPD\n#| fig-cap: \"This plot shows the relationship between VPD, TA, and RH over a range of possible values\"\n#| layout-ncol: 1\n#| warning: False\n\nimport numpy as np\nimport pandas as pd\nimport tensorflow as tf\nimport matplotlib.pyplot as plt\n\nfrom Scripts import MiscFuncs,PlotHelpers\n\nunits = {\n    'TA':'$T_a^\\circ$C',\n    'RH':'RH %',\n    'VPD':'VPD hPa'\n    }\n\nlabels = {\n    'TA':'Air Temperature',\n    'RH':'Relative Humidity',\n    'VPD':'Vapor Pressure Deficit'\n    }\n\nrange_TA_RH,grid_TA,grid_RH,grid_VPD = MiscFuncs.Create_Grid(\n    np.linspace(-50,50),# Define a TA range (in C)\n    np.linspace(0,100), # Possible RH values\n    MiscFuncs.Calc_VPD # Return Vapor Pressure Defecit\n    )\n    \nbins = np.arange(-10,grid_VPD.max(),15)\ncmap = 'PuRd'\nnorm = [0,grid_VPD.max()]\n\nfig,ax=plt.subplots(1,figsize=(5,5))\nPlotHelpers.Contour_Plot(fig,ax,grid_TA,grid_RH,grid_VPD,cmap=cmap,norm=norm,unit = units['VPD'],bins=bins)\nax.set_xlabel('Air Temperature $^\\circ$C')\nax.set_ylabel('Relative Humidity %')\nax.set_title('Vapor Pressure Deficit (VPD)')\nplt.tight_layout()\n\n# Use tensorfolow to calculate the first partial derivative of the function\nX_tensor = tf.convert_to_tensor(range_TA_RH.T)\nwith tf.GradientTape(persistent=True) as tape:\n    tape.watch(X_tensor)\n    VPD_est = MiscFuncs.Calc_VPD(X_tensor) \n# Get gradients of VPD_est with respect to X_tensor\nDeriv = tape.gradient(VPD_est,X_tensor).numpy()\n\n\nDerivatives = pd.DataFrame(\n    data={\n    'TA':range_TA_RH.T[:,0],\n    'RH':range_TA_RH.T[:,1],\n    'dVPD/dTA':Deriv[:,0],\n    'dVPD/dRH':Deriv[:,1]\n    }\n)\n\nfig,axes=plt.subplots(2,2,figsize=(8,8),sharey='row')\n\ngrid_dVPD_dTA = Deriv[:,0].T.reshape(grid_TA.shape)\ngrid_dVPD_dRH = Deriv[:,1].T.reshape(grid_RH.shape)\n\nd_bins = np.arange(\n    np.floor(Deriv).min(),np.ceil(Deriv).max(),.5\n    )\nd_cmap = 'bwr'\nd_norm = [\n    Deriv.min(),0, Deriv.max()\n    ]\n    \nax,_ = PlotHelpers.Contour_Plot(fig,axes[0,0],grid_TA,grid_RH,grid_dVPD_dTA,cmap = d_cmap,norm=d_norm,bins=d_bins)\nax.set_title('dVPD dTa')\n\nax,_ = PlotHelpers.Contour_Plot(fig,axes[0,1],grid_TA,grid_RH,grid_dVPD_dRH,cmap = d_cmap,norm=d_norm,bins=d_bins)\nax.set_title('dVPD dRH')\n\n\ny=['dVPD/dTA']\ndf = MiscFuncs.byInterval(Derivatives,'TA',y,bins=100)\nax = PlotHelpers.CI_Plot(axes[1,0],df,y[0])\n# ax.set_title('Partial First Derivative\\nVPD with respect to Ta')\n\ny=['dVPD/dRH']\ndf = MiscFuncs.byInterval(Derivatives,'RH',y,bins=100)\nax = PlotHelpers.CI_Plot(axes[1,1],df,y[0])\n# ax.set_title('Partial First Derivative\\nVPD with respect to RH')\n\n\nplt.tight_layout()\n\n```\n\n## Partial Derivatives\n\n```{python}\n#| label: Derivatives of VPD\n#| fig-cap: \"This plot shows the partial first derivatives of VPD\"\n#| layout-ncol: 1\n#| warning: False\ngrid_VPD.min()\n\n\n```\n\n\n## Example Data\n\nBB1 Flux tower was established in 2015.\n\n```{python}\nfrom Scripts import ReadDB\n\n# dbNames = {\n#     'TA_1_1_1':'TA',\n#     'RH_1_1_1':'RH'\n# }\n\n# read_new = False\n# if read_new == False:\n#     Data = ReadDB.get_Traces('BB',['TA_1_1_1','RH_1_1_1'],Dir='/mnt/c/Users/User/PostDoc_Work/database/')\n#     print(Data)\n#     Data = Data.dropna(axis=0)\n#     Data = Data.rename(columns=dbNames)\n#     Data.to_csv('temp/BB1_VPD.csv')\n\n# else:\nSite = 'BB'\nData = pd.read_csv(f'temp/{Site}_VPD.csv',parse_dates=['TimeStamp'],index_col='TimeStamp')\n    \nprint(Data.head())\n\nData['VPD'] = MiscFuncs.Calc_VPD(Data['TA'],Data['RH'])\n    \nfig,axes=plt.subplots(1,3,figsize=(7,4))\nData.hist(column='TA',ax=axes[0],bins=20,edgecolor='k')\naxes[0].set_xlabel(units['TA'])\n\nData.hist(column='RH',ax=axes[1],bins=20,edgecolor='k')\naxes[1].set_xlabel(units['RH'])\n\nData.hist(column='VPD',ax=axes[2],bins=20,edgecolor='k')\naxes[2].set_xlabel(units['VPD'])\n\nplt.tight_layout()\n\nData.describe().round(1)\n```\n\n\n## Artificial Gaps\n\n\n```{python}\n#| label: fig-format\n#| fig-cap: \"Format the training data\" \n#| layout-ncol: 1\n#| warning: False\n\nX_vars = ['TA', 'RH']\nY_var = 'VPD'\n\n# X_full = Data[X_vars].values\n# Y_full = Data[Y_var].values\n# print('Full Training Samples: ',Y_full.shape)\n\n# Mask = np.array([-1,1])\n# # Masked dataset for training\n# x_mask = Data.loc[(\n#     (Data[Y_var]<Mask.min())|(Data[Y_var]>Mask.max())\n#     ),X_vars].values\n# y_mask = Data.loc[(\n#     (Data[Y_var]<Mask.min())|(Data[Y_var]>Mask.max())\n#     ),Y_var].values\n# print('Masked Samples: ',y_mask.shape)\n\n# # Missing values for assessing performance\n# x_missing = Data.loc[Data[Y_var].isin(y_mask)==False,X_vars].values\n# y_missing = Data.loc[Data[Y_var].isin(y_mask)==False,Y_var].values\n# print('Missing Samples: ',y_missing.shape)\n\n# Make some artificial gap scenarios\n\n# Scenarios = {\n#     \"Random Drop Out\":{}\n#     \"Missing Middle\":{}\n#     \"Clipped Wings\":{}\n# }\n\nMask = np.array([[-1,1],[2,3]])\nMasked,Dropped = MiscFuncs.makeMask(Data,Y_var,Mask)\n\nprint(Masked.shape,Dropped.shape)\n\n\n# print(Mask.ndim)\nfor mask in Mask:\n    print(mask)\n```\n\n\n\n## Conclusions\n\nThey offer the user more control over the structure of the model and inspection of the model derivatives provides a method for validating that the relationships mapped by a model are physically plausible.\n\n## Questions"},"formats":{"revealjs":{"execute":{"fig-width":10,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":false,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","html-math-method":{"method":"mathjax","url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML-full"},"slide-level":2,"to":"revealjs","citeproc":true,"output-file":"about.html"},"language":{},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.2.335","auto-stretch":true,"title":"A Framework for Applying Neural Networks to Eddy Covariance Data","jupyter":"python3","author":[{"name":"Dr. June Skeeter","email":"june.skeeter@ubc.ca","url":"https://github.com/June-Skeeter","affiliations":[{"ref":"UBC"}]}],"affiliations":[{"id":"UBC","name":"University of British Columbia","department":"Department of Geography","address":"1984 West Mall","city":"Vancouver, BC, Canada","postal-code":"V6T 1Z2"}],"keywords":["Eddy Covariance","Micrometeorology","Neural Networks","Modelling"],"bibliography":["ML_EC.bib"],"controls":true,"navigationMode":"linear","controlsLayout":"bottom-right","controlsTutorial":true,"slideNumber":true,"showSlideNumber":"all","pdfMaxPagesPerSlide":1}}}}